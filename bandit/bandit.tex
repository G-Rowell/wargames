\documentclass[a4paper]{article}

\usepackage[margin=2.5cm]{geometry}

\usepackage{listings}
\lstset{ %Src: https://tex.stackexchange.com/questions/499219/remove-ugly-space-under-lstlisting
    backgroundcolor=\color{gray!10},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
    %basicstyle=\footnotesize,        % the size of the fonts that are used for the code
    breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
    breaklines=true,                 % sets automatic line breaking
    commentstyle=\color{cyan},    % comment style
    escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
    extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
    keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
    %keywordstyle=\color{darkblue},       % keyword style
    language=bash,       			  % the language of the code
    % numbers=left,             
    otherkeywords={xxx},
    numbersep=5pt,                   % how far the line-numbers are from the code
    showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
    showstringspaces=false,          % underline spaces within strings only
    showtabs=false,                  % show tabs within strings adding particular underscores
    stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
    %stringstyle=\color{red},     % string literal style
    tabsize=2,                     % sets default tabsize to 2 spaces
    morekeywords={ssh, ls, less, grep, find, sort, uniq, strings, base64
    				, tr, mktemp, file, xxd, zcat, bzcat, tar, nc, openssl
    				, nmap, diff, suconnect}
}

\usepackage{xcolor}

\usepackage{hyperref} %for hyperlinks
\hypersetup{
	colorlinks=true,    
	urlcolor=blue,
}  

\newcommand{\pass}[1]{\textbf{Password to enter:} \textit{#1}\\}
\newcommand{\chall}{\textbf{Challenge:} }

\begin{document}
\title{Work \& documentation notes of various wargames}
\author{Galen Rowell}
\maketitle


\section{Bandit}
\subsection{Levels}

\subsubsection{bandit0}
\pass{bandit0}
\chall Solved using the \textbf{ssh} command, which included use of flags to set user \& port.
\begin{lstlisting}
ssh bandit0@bandit.labs.overthewire.org -p 2220
\end{lstlisting}

\subsubsection{bandit1}
\pass{boJ9jbbUNNfktd78OOpsqOltutMc3MY1}
\chall Reading a file named '-', this was problematic due to many common shell commands using '-' to prefix an option or flag.
\begin{lstlisting}
cat ./-
\end{lstlisting}

\subsubsection{bandit2}
\pass{CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9}
\chall With spaces in a filename, shell programs will interpret the input as several arguments (instead of one space-delimited string). This issue can be solved two ways.
\begin{lstlisting}
cat 'spaced filename'
\end{lstlisting}
\begin{lstlisting}
cat spaced\ filename
\end{lstlisting}

\subsubsection{bandit3}
\pass{UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK}
\chall The file is prepended by a '.', which causes it to be hidden from most views. The \textit{-A} flag for \textbf{ls} will show all hidden files except '.' \& '..', which are part of the directory itself.
\begin{lstlisting}
ls -A1
\end{lstlisting}

\subsubsection{bandit4}
\pass{pIwrPrtPN36QITSp3EQaw936yaFoFgAB}
\chall The file is hidden in one of '~/inhere/-file{0,9}'. They contain special characters that interfere with the terminal environment. The use of \textbf{file} aids as it lists the encoding of a given file.
\begin{lstlisting}
file ./*
\end{lstlisting}

\subsubsection{bandit5}
\pass{koReBOKuIDDepwhWk7jZC0RTdopnAYKh}
\chall The file is within one of many sub-folders, with human readable encoding and a file size of '1033' bytes. The use of \textbf{ls} with the recursive flag \textit{-R}, combined with \textbf{grep} to select the file with the given size solves this problem.
\begin{lstlisting}
ls -Al -R | grep --color -C 5 -e '1033'
\end{lstlisting}

\subsubsection{bandit6}
\pass{DXjZPULLxYr17uwoI01bNLQbtFemEgo7}
\chall The file is somewhere on the server, so we should search recursively from the root of the drive. We are given the owner name, group name and size of the file, which we can plug into \textbf{find} to find the file.
\begin{lstlisting}
find / -group bandit6 -size 33c 2>&1 | grep -v "Permission denied"
\end{lstlisting}
\textit{Note: The use of a terminal redirect and \textbf{grep} remove the output of excessive file permission warnings}

\subsubsection{bandit7}
\pass{HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs}
\chall This level is a simple grep search for the word \textit{millionth} in a large keyword text file.

\subsubsection{bandit8}
\pass{cvX2JJa4CFALtqS87jk27qwqGhBM9plV}
\chall The password is the only line that occurs once within an unordered text file.
\begin{lstlisting}
sort data.txt | uniq -u
\end{lstlisting}
\textit{Note: The -u flag of \textbf{uniq} ensures only lines of 1 occurrence are printed}

\subsubsection{bandit9}
\pass{UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR}
\chall The given file is a binary encoded file, IE. it is not in plaintext or easy to read. \textbf{strings} will only print human-readable strings from a given input, and the use of \textbf{grep} will limit the output to a manageable size.
\begin{lstlisting}
strings data.txt | grep -Ee [=]+
\end{lstlisting}
\textit{Note: The [=]+ pattern of \textbf{grep} searches for one or more occurances of \textit{=} in each line, EG. \textit{=}, \textit{====} or \textit{========}}

\subsubsection{bandit10}
\pass{truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk}
\chall The file is encoded in base 64, which can be encoded and decoded using the \textbf{base64} program.
\begin{lstlisting}
base64 -d data.txt
\end{lstlisting}

\subsubsection{bandit11}
\pass{IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR}
\chall The file is encoded in a ROT-13 cipher, meaning that all letters in the alphabet have been shifted 13 places. \textbf{tr} is a unix program which is used the \textbf{tr}anslate various sets of text.
\begin{lstlisting}
cat data.txt | tr "n-za-mN-ZA-M" "a-zA-Z"
\end{lstlisting}

\subsubsection{bandit12}
\pass{5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu}
\chall The given file is a hexdump of a binary file, which is a compressed \textbf{gzip} file. The \textbf{gzip} file is itself compressed many times with \textbf{gzip, bzip2} \& \textbf{tar}. One of the best ways to discover what encoding a file has is to run \textbf{file} on the given file, as well as visual inspection with \textbf{less}.
\\\\
The methodology used to solve the level was to inspect the file encoding using \textbf{file}, find the appropriate decompression program, then repeat until the end result was the final plain-text.
\\\\
\textbf{gzip} has a 'unix-pipe' program version named \textbf{zcat}.\\
\textbf{bzip2} has a 'unix-pipe' program version named \textbf{bzcat}.\\
\textbf{tar} acts like a 'unix-pipe' program with the arguments \textbf{tar xO}.
\\
The use of these \textit{unix-pipe} versions allow use to pipe the input through \textit{std-in} and have the decompressed output sent to \textit{std-out}.
\begin{lstlisting}[title=to uncompress a hexdump]
xxd -r data.txt a.bin
\end{lstlisting}
\begin{lstlisting}[title=to test the file encoding/type from std-in]
file -
\end{lstlisting}
\begin{lstlisting}[title=the series of decompression required]
xxd -r data.txt a.bin
zcat a.bin | bzcat | zcat | tar xO | tar xO | bzcat | tar xO | zcat
\end{lstlisting}

\subsubsection{bandit13}
\pass{8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL}
\chall This is a small challenge regarding SSH keys, a private key to access the next level is given. \textbf{ssh}'s \textbf{-i} flag uses the given key to authenticate the connection.
\begin{lstlisting}
ssh bandit14@localhost -i sshkey.private
\end{lstlisting}

\subsubsection{bandit14}
\pass{4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e}
\chall This passwords for the next level is retreieved by sending the password for the current level to port 30,000 of the machine \textit{(IE. localhost)}. This was solved by using a dated, but universal, shell program called \href{https://en.wikipedia.org/wiki/Netcat}{\textbf{n}et \textbf{c}at}.
\begin{lstlisting}[numbers=left]
nc localhost 30000
	4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e
	Correct!
	BfMYroe26WYalil77FoDi9qh59eK5xNr
\end{lstlisting}
\textit{Note: Line \#2 was entered manually, lines \#3-4 were a 'response' from port 30,000}

\subsubsection{bandit15}
\pass{BfMYroe26WYalil77FoDi9qh59eK5xNr}
\chall This challenge covers the use of \textbf{openssl}, and it's broad uses as a cryptographic tool for certificate and key generation/management. \textbf{openssl} has many sub-commands, of particular note is the \textbf{s\_c lient} sub-command.
\begin{lstlisting}
cat bandit15 | openssl s_client -connect localhost:30001 -ign_eof
\end{lstlisting}
\textit{Note: the flag '-ign\_eof' is used to allow the piping from cat into the session, alternatively the text can be manually input.}

\subsubsection{bandit16}
\pass{cluFn7wTiGryunymYOu4RcffSxQluehd}
\chall This challenge expands more upon basic TCP/IP technologies, and covers port scanning with the use of \textbf{nmap}. \textbf{nmap} is an extremely powerful and ubiquitous ip \& port scanning tool. It can be used to detect open ports and what they are running to detecting the OS a given machine is running.\begin{lstlisting}[title=scan ports 31000 32000 of localhost and attempt to discover what they are running]
nmap -sV -p 31000-32000 localhost
\end{lstlisting}

\subsubsection{bandit17}
\pass{xLYVMN9WE5zQ5vHacb0sZEVqbrp7nBTn}
\chall This challenge is a simple use of \textbf{diff}, to find the password which is the one line of difference between the two files.
\begin{lstlisting}
diff passwords.new passwords.old
\end{lstlisting}

\subsubsection{bandit18}
\pass{kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd}
\chall The login shell environment for level 18 automatically logs the user out. This prevents users from entering in any commands but is solved by using a feature of \textbf{ssh}, in which a command can be specified (instead of invoking a login shell).
\begin{lstlisting}
ssh [...various flags/options...] destination [command]
ssh bandit18@bandit.labs.overthewire.org -p 2220 /bin/sh
\end{lstlisting}

\subsubsection{bandit19}
\pass{IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x}
\chall This covers the shell programs \href{https://en.wikipedia.org/wiki/Setuid}{\textbf{setuid} \& \textbf{setgid}}. 

According to Wikipedia: \textit{\textbf{setuid} and \textbf{setgid} (short for "set user ID" and "set group ID") are Unix access rights flags that allow users to run an executable with the permissions of the executable's owner or group respectively and to change behaviour in directories. They are often used to allow users on a computer system to run programs with temporarily elevated privileges in order to perform a specific task}

In essence they allow a user to execute a file as if they were a different (possibly higher-privileged) user.

\subsubsection{bandit20}
\pass{GbKksEFF4yrVs6il55v6gwY5aVje5f0j}
\chall This level covers LINUX jobs, which enable the pausing of an active process, sending it to the background and other various features. This allows us to do things like set a server running in the background and connect to it all from the same terminal.
\begin{lstlisting}[numbers=left]
nc -l -p 30101 &
./suconnect 30101 &
fg 1
	nc -l -b -p 30101
	GbKksEFF4yrVs6il55v6gwY5aVje5f0j
	Read: GbKksEFF4yrVs6il55v6gwY5aVje5f0j
	Password matches, sending next password
	gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr
\end{lstlisting}
\textit{Note: Line \#5 was entered by the user}

\subsection*{Links \& resources}
\begin{enumerate}
\item The bandit wargame is run on a remote server, accessed by ssh. In order to write scripts to log what I executed and re-run/solve the level then a tool is needed to be able to feed the password during the handshake process. SSHpass is great for this: \href{https://askubuntu.com/questions/224181/how-do-i-include-a-password-with-ssh-command-want-to-make-shell-script}{SSHPass tutorial} 

\item When scripting, it is often useful to have a temporary directory where files can be created \& modified without the risk of littering such files about the filesystem. So a temporary directory (often in /tmp/) is useful, \href{https://code-maven.com/create-temporary-directory-on-linux-using-bash}{\textbf{mktemp}} does this:
	\begin{lstlisting}[title=move to the new temporary directory]
	cd $(mktemp -d)
	\end{lstlisting}
	\begin{lstlisting}[title=store the new temporary directory path]
	tmp_dir=$(mktemp -d)
	\end{lstlisting}
\end{enumerate}
\end{document}